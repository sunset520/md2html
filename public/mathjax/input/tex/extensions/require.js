(()=>{"use strict";var e={d:(t,a)=>{for(var r in a)e.o(a,r)&&!e.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:a[r]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{RequireConfiguration:()=>P,RequireLoad:()=>y,RequireMethods:()=>w,options:()=>k});const a=("undefined"!=typeof window?window:global).MathJax._.components.global,r=(a.GLOBAL,a.isObject,a.combineConfig,a.combineDefaults,a.combineWithMathJax),o=a.MathJax,n=MathJax._.input.tex.Configuration,i=n.Configuration,s=n.ConfigurationHandler,p=(n.ParserConfiguration,MathJax._.input.tex.TokenMap),u=(p.parseResult,p.AbstractTokenMap,p.RegExpMap,p.AbstractParseMap,p.CharacterMap,p.DelimiterMap,p.MacroMap,p.CommandMap),c=(p.EnvironmentMap,MathJax._.input.tex.TexError.default),l=MathJax._.components.package,f=(l.PackageError,l.Package),g=("undefined"!=typeof window?window:global).MathJax._.components.loader,d=(g.PathFilters,g.Loader),h=(g.MathJax,g.CONFIG),x=MathJax._.mathjax.mathjax,m=MathJax._.util.Options,M=(m.isObject,m.APPEND,m.REMOVE,m.OPTIONS,m.Expandable,m.expandable),O=(m.makeArray,m.keys,m.copy,m.insert,m.defaultOptions,m.userOptions,m.selectOptions,m.selectOptionsFromKeys,m.separateOptions,m.lookup,o.config);function b(e,t){const a=e.parseOptions.options.require,r=e.parseOptions.packageData.get("require").required,o=t.substring(a.prefix.length);if(r.indexOf(o)<0){r.push(o);let a=function(e,t=[]){const a=e.parseOptions.options.require.prefix,r=[];for(const o of t)if(o.substring(0,a.length)===a)try{b(e,o)}catch(e){if(!e.retry)throw e;r.push(e.retry)}return r.length?Promise.all(r):null}(e,h.dependencies[t]);a?x.retryAfter(a.then((()=>q(e,t,o)))):q(e,t,o)}}function q(e,t,a){const r=s.get(a);if(r){let o=O[t]||{};r.options&&1===Object.keys(r.options).length&&r.options[a]&&(o={[a]:o}),e.configuration.add(a,e,o);const n=e.parseOptions.packageData.get("require").configured;r.preprocessors.length&&!n.has(a)&&(n.set(a,!0),x.retryAfter(Promise.resolve()))}}function y(e,t){const a=e.options.require,r=a.allow,o=("["===t.substring(0,1)?"":a.prefix)+t;if(!(r.hasOwnProperty(o)?r[o]:r.hasOwnProperty(t)?r[t]:a.defaultAllow))throw new c("BadRequire",'Extension "%1" is not allowed to be loaded',o);f.packages.has(o)?b(e.configuration.packageData.get("require").jax,o):x.retryAfter(d.load(o))}const w={Require(e,t){const a=e.GetArgument(t);if(a.match(/[^_a-zA-Z0-9]/)||""===a)throw new c("BadPackageName","Argument for %1 is not a valid package name",t);y(e,a),e.Push(e.itemFactory.create("null"))}},k={require:{allow:M({base:!1,"all-packages":!1,autoload:!1,configmacros:!1,tagformat:!1,setoptions:!1,texhtml:!1}),defaultAllow:!0,prefix:"tex"}};new u("require",{require:"Require"},w);const P=i.create("require",{handler:{macro:["require"]},config:function(e,t){t.parseOptions.packageData.set("require",{jax:t,required:[...t.options.packages],configured:new Map});const a=t.parseOptions.options.require,r=a.prefix;if(r.match(/[^_a-zA-Z0-9]/))throw Error("Illegal characters used in \\require prefix");h.paths[r]||(h.paths[r]="[mathjax]/input/tex/extensions"),a.prefix="["+r+"]/"},options:k});MathJax.loader&&MathJax.loader.checkVersion("[tex]/require","4.0.0-beta.6","tex-extension"),r({_:{input:{tex:{require:{RequireConfiguration:t}}}}})})();